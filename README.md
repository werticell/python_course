Python Course
===============
Небольшая часть заданий курса по Python ФПМИ ПМИ 2019-2020.

## Lab
Задание на использование библиотек Pandas и Matplotlib.
В этом задании предлагается выполнить анализ данных криптовалют
с помощью библиотек pandas и matplotlib.

## Contest 4. Generators/Decorators

#### A. Треугольный генератор Паскаля
Напишите генератор, возвращающий бесконечную последовательность чисел из треугольника Паскаля.<br/>
Последовательность, возвращаемая генератором, должна выглядеть так:
1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 1 8 28 56 70 56 28 8 1 1 9 36 84 126 126 84 36 9 1 ...

#### B. Сливаемся!
Напишите генератор, выполняющий слияние отсортированных последовательностей целых чисел.<br/>
Сдавать нужно только код самого генератора, тестирующий код импортирует его и прогонит набор тестов. <br/>
Генератор принимает произвольное число аргументов. Аргументом может быть любой итерируемый объект, в том числе другой генератор. Гарантируется, что каждый аргумент — это последовательность целых чисел, отсортированных в порядке неубывания.<br/>

#### C. Декоратор проверки аргументов
Напишите декоратор @takes, который будет проверять правильность типов входных аргументов функции.<br/>
Декоратор принимает на вход типы аргументов и декорирует функцию таким образом, что она генеририрует исключение TypeError, если хотя бы один из аргументов имеет неверный тип.<br/>
Если аргументов больше, чем типов, то ошибку генерировать не нужно (возможно, точный тип известен только для первых аргументов, его, как раз, надо проверить).<br/>
Если типов больше, чем аргументов, то это тоже ошибка только в случае, если переданные аргументы не подходят под соответствующие им по порядку типы. (декоратор может быть применен к функциям с переменным числом аргументов).<br/>
Декоратор должен вести себя порядочно, то есть не должен затирать основные аргументы функции (__name__, __doc__, __module__).<br/>
Для простоты можно считать, что у функции нет именованных аргументов

#### D. LRU cache decorator
Бывает полезно оптимизировать вызовы "тяжёлых"функций с помощью кеширования. Кеширование – это сохранение результатов выполнения функций для предотвращения повторных вычислений. Перед вызовом функции проверяется есть ли уже вычисленный результат. Если есть – функция не вызывается, а возвращается сохранённое значение.<br/>
Реализуйте декоратор для Least Recently Used (LRU) Cache. Пользователь указывает размер кеша N, и в кеше сохраняются N последних вычислений. Другими словами, вытесняется из кеша сначало то, что использовалось давней всего.<br/>
Декоратор назовите @cache, он должен принимать один параметр – размер кеша. Поддержите как можно более широкий класс функций (функции многих аргументов, функции с именоваными параметрами, принимающие сложные типы итд). Декоратор должен вести себя порядочно, то есть не должен затирать документацию функции.<br/>

#### E. Профилятор
Напишите декоратор @proﬁler, который при вызове функции будет сохранять в её атрибуты время ее исполнения (в секундах, можно дробное) и количество рекусивных вызовов произошедших при исполнении. Атрибуты назовите last_time_taken и calls.<br/>
Пользоваться глобальными переменными запрещено.<br/>
Декоратор должен вести себя порядочно, то есть не должен затирать документацию функции.<br/>
Сдавать нужно только код самого декоратора, тестирующий код импортирует его и прогонит набор тестов. Тестирующий код импортирует из вашего модуля декоратор и прогонит на наборе тестов.<br/>

## Contest 6. OOP
#### A. Улучшенный список
Напишите класс, который является расширением стандартного класса list. Сделайте так, чтобы, помимо обычных атрибутов в нем присутствовали такие:
- **reversed** (с коротким псевдонимом R), который содержит тот же список, но с элементами в обратном порядке.
- **first** (с коротким псевдонимом F), который содержит первый элемент списка. Должна присутствовать возможность изменять этот атрибут (и вместе с ним должен меняться и сам список). Атрибут не обязан работать корректно, если список пустой.
- **last** (с коротким псевдонимом L), который содержит последний элемент списка. Должна присутствовать возможность изменять этот атрибут (и вместе с ним должен меняться и сам список). Атрибут не обязан работать корректно, если список пустой.
- **size** (с коротким псевдонимом S), который содержит размер списка. Должна присутствовать возможность изменять этот атрибут: при увеличении размера в конец должны добавляться значения None, а при уменьшении последние элементы должны удаляться.<br/>
Обратите внимание, что все перечисленные атрибуты не являются методами (см. пример). Однако их рекомендуется не хранить, а вычислять «на лету».
#### B. Очень Важный Класс
Хакер Лёша нашёл уязвимость в известном сервисе. Он хочет построить вредоносную систему, почти не отличимую от старой, а потому хочет воспользоваться Самым Важным Классом взломанной системы. Беда в том, что доступа к коду класса нет, его можно только импортировать. Хакеры пишут на ассемблере и теряются, когда речь идет о высокоуровневых языках, поэтому вам придётся помочь Лёше.<br/>
Часть коварного плана, которую вам предстоит реализовать, состоит в том, чтобы взять Очень Важный Класс и сконструировать на его основе новый. Остальное мы сделаем за вас.<br/>
Вредоносные изменения, которые вам предстоит внести по сравнению с оригинальным классом:
- Обернуть все методы в декоратор (он вам тоже неизвестен, но уже написан и ждёт своего часа)
- При попытке получить атрибут класса, значение которого является числом, возвращаемое значение нужно умножить на два
- Если значение атрибута – это контейнер, нужно вернуть контейнер такого же типа, но пустой (для простоты можно считать, что все типы-контейнеры инициализируются одинаково, например, пустой список можно создать с помощью **list()**). С определением того, что такое контейнер, вам поможет документация модуля **collections.abc**
Кстати, Лёша – вежливый хакер, поэтому он не изменяет никакие атрибуты/методы/etc класса, не входящие в публичный интерфейс (начинающиеся с символа '_')
Ваше решение не должно ничего выводить на экран, ваша задача – только определить **HackedClass**.
#### C. Глючный модуль
Предположим такую невозможную ситуацию: у вас есть модуль на python, который не работает.<br/>
При попытке его импорта интерпретатор ругается на какое-то количество синтаксических ошибок и непонятных исключений.<br/> 
Но выход есть! <br/>
Напишите функцию force_load, которая будет импортировать этот злосчастный модуль и выкидывать из него все строчки с ошибками.


Пусть на вход она принимает имя модуля, который лежит в той же директории, а возвращает словарь со всеми объектами, которые удалось без ошибок создать на этапе импорта. 
##### Примечание
Обратите внимание, что есть очень особенные исключения SyntaxError. Если программа часть исключений обрабатывает, а часть нет – дело скорее всего именно в них.<br/>
[Если](https://docs.python.org/3/library/exceptions.html#SyntaxError) совсем непонятно, стоит посмотреть у объекта перехваченного исключения атрибут args, там вся необходимая наводящая информация.
#### D. Контекстные менеджеры среднего звена
Чудесная штука – исключения. В комплекте же с контекстными менеджерами их возможности возрастают многократно.
Напишите несколько контекстных менеджеров для обработки исключений.<br/>
***Глушитель исключений***

     with supresser(type_one, ...): 
         do_smth()
перехватывает исключения заданых (и только заданных) типов и возвращает управление потоку. Исключение не пробрасывается дальше.<br/>
***Переименователь исключений***

     with retyper(type_from, type_to): 
        do_smth()
меняет тип исключения, оставляя неизменными содержимое ошибки (атрибут args) и трейсбек. Исключение пробрасывается дальше.<br/>
***Дампер исключений***

     with dumper(stream): 
        do_smth()
записывает в объект stream тело и трейсбек исключения в необычном порядке: сначала ошибка, потом трейсбек исключение пробрасывается дальше.
предполагается что у объекта stream обязательно должен быть метод write (для отладки можно использовать io.StringIO()).
##### Примечание
Вам может пригодиться [упрощённый способ](https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager) создания контекстных менеджеров.<br/>
Обратите внимание, что менеджер ***supress*** надо реализовывать самостоятельно.
